# 181 荒岛求生

## 题目描述

有一个荒岛，只有左右两个港口，只有一座桥连接这两个港口，现在有一群人需要从两个港口逃生，有的人往右逃生，有的往左逃生，如果两个人相遇，则PK一下，体力值大的能够打赢体力值小的，体力值相同则同归于尽，赢的人才能继续往前逃生，并减少相应的体力。

## 输入描述

输入一列非0整数，用空格分隔，正数代表向右逃生，负数代表向左逃生。

## 输出描述

最终能够逃生的人数。

## 示例描述

### 示例一

**输入：**
```text
5 10 8 -8 -5
```

**输出：**
```text
2
```

**说明：**  

- 向右逃生的体力值为8的人与向左逃生的体力值为8（-8）的人相遇，同归于尽。
- 向右逃生的体力值为10遇到向左逃生的体力值为5（-5）的人，10打赢了，并减少5点体力。 
  
最终逃生的为`[5,5]`，均从右侧港口逃生，输出2。

## 解题思路

1. 将正数放入右侧列表`right`，负数的绝对值放入左侧列表`left`
2. 将右侧列表逆转一次。
3. 迭代处理左侧和右侧列表，模拟两人相遇的情况：
    - 当左侧第一个人的体力值大于右侧第一个人的体力值，则左侧的人的体力值减去右侧的人的体力值，在右侧列表中删除第一个人。
    - 当左侧第一个人的体力值小于右侧第一个人的体力值，则右侧的人的体力值减去左侧的人的体力值，在左侧列表中删除第一个人。
    - 如果相等，则两个列表中都删除第一个人。
4. 返回两个列表的长度之和。   

## 解题代码

```python
def solve_method(nums):
    # 将正数放入右侧列表，负数的绝对值放入左侧列表
    left = [abs(x) for x in nums if x <= 0]
    right = [x for x in nums if x > 0]
    right = right[::-1]

    # 迭代处理左侧和右侧列表
    while right and left:
        if left[0] > right[0]:
            left[0] -= right.pop(0)
        elif left[0] < right[0]:
            right[0] -= left.pop(0)
        else:
            left.pop(0)
            right.pop(0)

    # 输出最终列表的长度之和
    return len(right) + len(left)


if __name__ == "__main__":
    assert solve_method([5, 10, 8, -8, -5]) == 2
```